<? php / * * * ____ _ _ __ __ _ __ __ ____ * | _ \ ___ ___ | | _____ | | _ | \ / (_) _ __ ___ | \ / | _ \ * | | _) / _ \ / __ | | / / _ \ __ | | \ / | | | '_ \ / _ \ _____ | | \ / | | | _) | * | __ / (_) | (__ | <__ / | _ | | | | | | | | __ / _____ | | | | | __ / * | _ | \ ___ / \ ___ | _ | \ _ \ ___ | \ __ | _ | | _ | _ | _ | | _ | \ ___ | | _ | | _ | _ | * * Эта программа является свободным программным обеспечением: вы можете распространять ее и / или изменять * в соответствии с условиями Стандартной общественной лицензии GNU, опубликованной * Free Software Foundation, либо 3-й версии Лицензии, либо * (по вашему выбору) любой более поздней версии. * * @author PocketMine Team * @link http://www.pocketmine.net/ * * * / Declare (strict_types = 1); пространство имен карманный; / ** * Этот класс должен быть расширен всеми пользовательскими классами потоков * / абстрактный класс Worker extends \ Worker { 	/ ** @var \ ClassLoader | null * / 	protected $ classLoader; 	/ ** @var string | null * / 	protected $ composerAutoloaderPath; 	protected $ isKilled = false; 	public function getClassLoader () { 		return $ this-> classLoader; 	} 	публичная функция setClassLoader (\ ClassLoader $ loader = null) { 		$ this-> composerAutoloaderPath = \ pocketmine \ COMPOSER_AUTOLOADER_PATH; 		if ($ loader === null) { 			$ loader = Server :: getInstance () -> getLoader (); 		} 		$ this-> classLoader = $ loader; 	} 	/ ** 	 * Регистрирует загрузчик классов для этого потока. 	 * 	 * ПРЕДУПРЕЖДЕНИЕ. Этот метод ДОЛЖЕН вызываться из метода run () любых дочерних потоков, чтобы сделать автозагрузку пригодной для использования. 	 * Если вы этого не сделаете, вы не сможете использовать новые классы, которые не были загружены при запуске потока 	 * (если вы не используете собственный автозагрузчик). 	 * / 	public function registerClassLoader () { 		if ($ this-> composerAutoloaderPath! == null) { 			require $ this-> composerAutoloaderPath; 		} 		if ($ this-> classLoader! == null) { 			$ this-> classLoader-> register (false); 		} 	} 	публичная функция start (? int $ options = \ PTHREADS_INHERIT_ALL) { 		ThreadManager :: getInstance () -> add ($ this); 		if ($ this-> getClassLoader () === null) { 			$ this-> setClassLoader (); 		} 		return parent :: start ($ options); 	} 	/ ** 	 * Останавливает поток наилучшим возможным способом. Попробуйте остановить это самостоятельно, прежде чем звонить. 	 * / 	public function quit () { 		$ this-> isKilled = true; 		if ($ this-> isRunning ()) { 			while ($ this-> unstack ()! == null); 			$ this-> Notify (); 			$ this-> завершение работы (); 		} 		ThreadManager :: getInstance () -> remove ($ this); 	} 	public function getThreadName (): string { 		return (new \ ReflectionClass ($ this)) -> getShortName (); 	} }